Your task is to find the transformation that maps the input grid to the output grid.

# DSL and code execution rules:
1. Every single code code block that you provide me with will be executed using Python's `exec` function.
2. The code block you write must be between <DSL> always and must always a function called `solve(grid)` where `grid` is a 2d matrix.
3. My code provided below must work for all outputs with DSL code that you generate. Here is my internal code of how I process your outputs:
```Python
string_output_from_claude = <the full output you generate> # full output where you generated DSL code
code = string_output_from_claude.split("<DSL>")[1].split("</DSL>")[0] # extract just the code
exec(code) # run exec on your code to use the solve function that you wrote
output = solve(grid) # this function must have been written by you, and created when i run exec
```

IMPORTANT RULES:
- Always visualize grids using the emoji_map instead of working with raw coordinates: {
    0: 'âš«',  # Black
    1: 'ðŸ”µ',  # Blue
    2: 'ðŸ”´',  # Red
    3: 'ðŸŸ¢',  # Green
    4: 'ðŸŸ¡',  # Yellow
    5: 'âšª',  # Light gray (using white circle as closest match)
    6: 'ðŸŸ£',  # Purple (closest match for pink)
    7: 'ðŸŸ ',  # Orange
    8: 'ðŸ”¹',  # Light blue (using small blue diamond as closest match)
    9: 'ðŸŸ¥',  # Dark red (using red square as closest match)
}
```python
emoji_map = {
    0: 'âš«', 1: 'ðŸ”µ', 2: 'ðŸ”´', 3: 'ðŸŸ¢', 4: 'ðŸŸ¡',
    5: 'âšª', 6: 'ðŸŸ£', 7: 'ðŸŸ ', 8: 'ðŸ”¹', 9: 'ðŸŸ¥'
}

def grid_to_emoji(grid):
    return '\n'.join([''.join([emoji_map[cell] for cell in row]) for row in grid])
```

Here are the grids:
{add_to_prompt}

Provide reasoning and solution code below:
